# Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит три кучи камней.
# Игроки ходят по очереди, первый ход делает Петя.
# За один ход игрок может добавить в одну из куч 16 или 32 камня или увеличить количество камней в куче в два раза.
# Игра завершается в тот момент, когда в сумме в кучах будет не менее 150 камней. Победителем считается игрок, сделавший последний ход.
# В начальный момент в кучах было (6, 2S, 3S) камней, 1 ≤ S ≤ 66  .
# Назовите минимальное значение S, при котором Петя может выиграть своим первым ходом.
from functools import lru_cache
lru_cache(None)
def f(a, b, d, c = 0):
    if a + b + d >= 150:
        return 0
    if c > 3:
        return 1000000
    t = [f(a*2, b, d,  c+1),f(a+16, b, d, c+1),f(a+32, b, d, c+1),
    f(a, b*2, d,  c+1),f(a, b+16, d, c+1),f(a, b+32, d, c+1),
    f(a, b, d*2,  c+1),f(a, b, d+16, c+1),f(a, b, d+32, c+1)]
    n = [i for i in t if i <= 0]
    if n:
        return -max(n) + 1
    return -max(t)

a = []
for i in range(1,67):
    if f(6, 2*i, 3*i) == 1:
        a.append(i)
print(min(a))
# Для игры, описанной в задании 19, найдите сумму значений S, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
# –Петя не может выиграть за один ход;
# – Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
a = []
for i in range(1,67):
    if f(6, 2*i, 3*i) == 2:
        a.append(i)
print(sum(a))
# у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
# – у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
a = []
for i in range(1,67):
    if f(6, 2*i, 3*i) == -2:
        a.append(i)
print(a)